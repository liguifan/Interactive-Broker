import datetime
import numpy as np
import pandas as pd
import Queue

from abc import ABCMeta, abstractmethod

from event import SignalEvent

class Strategy(object):
    """
        Strategy is an abstract base class providing an interface for
        all subsequent (inherited) strategy handling objects.
        
        The goal of a (derived) Strategy object is to generate Signal
        objects for particular symbols based on the inputs of Bars
        (OLHCVI) generated by a DataHandler object.
        
        This is designed to work both with historic and live data as
        the Strategy object is agnostic to the data source,
        since it obtains the bar tuples from a queue object.
        """
    
    __metaclass__ = ABCMeta
    
    @abstractmethod
    def calculate_signals(self):
        """
            Provides the mechanisms to calculate the list of signals.
            """
        raise NotImplementedError("Should implement calculate_signals()")


class BuyAndHoldStrategy(Strategy):
    """
        This is an extremely simple strategy that goes LONG all of the
        symbols as soon as a bar is received. It will never exit a position.
        
        It is primarily used as a testing mechanism for the Strategy class
        as well as a benchmark upon which to compare other strategies.
        """
    
    def __init__(self, bars, events):
        """
            Initialises the buy and hold strategy.
            
            Parameters:
            bars - The DataHandler object that provides bar information
            events - The Event Queue object.
            """
        self.bars = bars
        self.symbol_list = self.bars.symbol_list
        self.events = events
        
        # Once buy & hold signal is given, these are set to True
        self.bought = self._calculate_initial_bought()
    
    
    def _calculate_initial_bought(self):
        """
            Adds keys to the bought dictionary for all symbols
            and sets them to False.
            """
        bought = {}
        for s in self.symbol_list:
            bought[s] = False
        return bought


    def calculate_signals(self, event):
        """
            For "Buy and Hold" we generate a single signal per symbol
            and then no additional signals. This means we are
            constantly long the market from the date of strategy
            initialisation.
        
            Parameters
            event - A MarketEvent object.
            """
        if event.type == 'MARKET':
            for s in self.symbol_list:
                bars = self.bars.get_latest_bars(s, N=1)
                if bars is not None and bars != []:
                    if self.bought[s] == False:
                    # (Symbol, Datetime, Type = LONG, SHORT or EXIT)
                        signal = SignalEvent(bars[0][0], bars[0][1], 'LONG')
                        self.events.put(signal)   # so there could be a list of signals at each hart beat
                        self.bought[s] = True


class technical_RSI(Strategy):
    """
    Relative Strength Index strategy 
    """

    def __init__(self, bars, events):
        """
        Initialises the strategy,
        Params:
        bars: The DataHandler object that provides bar information
        events: The Event Queue object
        """
        self.bars = bars
        self.symbol_list = self.bars.symbol_list
        self.events = events

        # Initialize the holding status to False
        self.boutght = self._calculate_initial_bought()


    def _calculate_initial_bought(self):
        """
        Set the holding status to False for all symbols
        """
        bought = {}
        for s in self.symbol_list:
            bought[s] =  False
        return bought

 
    def calculate_signals(self, event, periods=3):
        """
        params:
        event: 
        periods: parameter of RSI, number of periods 
        """
        if event.type == "MARKET":
            for s in self.symbol_list:
                bars = self.bars.get_latest_bars(s, periods+1)
                # Wait until at least "periods"+1 time periods market data is available
                if len(bars) == periods+1:
                    # Calculate RSI
                    close_price = [x[4] for x in bars] # close price for "periods"+1 periods
                    close_price_diff = [close_price[i] - close_price[i-1] for i in range(1, periods+1)]
                    ups_ = [x for x in close_price_diff if x > 0]
                    drops_ = [x for x in close_price_diff if x < 0]
                    ups_total = sum(ups_)
                    drops_total = sum(drops_)
                    RS = ups_total / drops_total
                    RSI = 100 * RS/(1+RS) # This is the RSI

                    # Calculate the direction and strenght of the signal
                    if RSI >= 70 and RSI < 80:
                        signal = SignalEvent(bars[0][0], bars[0][1], 'SHORT', "weak")
                    elif RSI >= 80 and RSI < 90:
                        signal = SignalEvent(bars[0][0], bars[0][1], 'SHORT', "mild")
                    elif RSI >= 90:
                        signal = SignalEvent(bars[0][0], bars[0][1], 'SHORT', "strong")
                    elif RSI <= 30 and RSI > 20:
                        signal = SignalEvent(bars[0][0], bars[0][1], 'LONG', "weak")
                    elif RSI <= 20 and RSI > 10:
                        signal = SignalEvent(bars[0][0], bars[0][1], 'LONG', "mild")
                    elif RSI <= 10:
                        signal = SignalEvent(bars[0][0], bars[0][1], 'LONG', "strong")

                    # Only when RSI is less than or equal to 30, or greater than or equal to
                    # 70, a trading signal will be triggered
                    if RSI <= 30 or RSI >= 70:
                        self.events.put(signal)